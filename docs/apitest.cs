// --------------------------------------------------
// <auto-generated>
//     This file was generated by Roslynator.Documentation, Version=0.1.0.0, Culture=neutral, PublicKeyToken=14b2ed2c2cb945dc
//     Assemblies:
//         Roslynator.Documentation.TestProject, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5c61873a6e840f26
// </auto-generated>
// --------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Versioning;

// Roslynator.Documentation.TestProject
[assembly: AssemblyCompany("Josef Pihrt")]
[assembly: AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyInformationalVersion("1.0.0.0")]
[assembly: AssemblyProduct("Roslynator.Documentation.TestProject")]
[assembly: AssemblyTitle("Roslynator.Documentation.TestProject")]
[assembly: TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = "")]

namespace System
{
    [CLSCompliant(true)]
    [Obsolete]
    public class ClassName<Methods>
    {
        public ClassName();

        public void MethodName();
    }
}

namespace Roslynator.Documentation.Test
{
    public class B
    {
        public const string FooConst = "abc";

        public string Field;

        public B();

        public event EventHandler Event;

        public int this[[Foo] [Foo] int index1, [Foo] int index2, [Foo] int index3] { get; }

        public string Property { [Foo] [Foo] get; }

        public string Method([Foo] [Foo] string s1, [Foo] string s2, [Foo] string s3);

        public class FooClass
        {
            public FooClass();
        }

        public struct FooStruct
        {
        }

        public interface IFoo
        {
            void M();
        }

        public enum FooEnum
        {
            None = 0,
        }

        public delegate void FooDelegate();
    }

    public class C : B
    {
        public string Field;

        public C();

        public event EventHandler Event;

        public int this[int index1, int index2, int index3] { get; }

        public string Property { get; }

        public string Method(string s1, string s2, string s3);
        public string ToString();

        public class FooClass
        {
            public FooClass();
        }

        public struct FooStruct
        {
        }

        public interface IFoo
        {
            void M();
        }

        public enum FooEnum
        {
            None = 0,
        }

        public delegate void FooDelegate();
    }

    [Obsolete("Foo is obsolete.")]
    public class Foo : Bla
    {
        public const string FooConst = "abc";

        public readonly string Field;

        public Foo(string s);
        public Foo(string s, string examples);

        public Foo this[int index, int index2] { get; set; }
        public Foo this[int index] { get; set; }

        public void Bar();
        public void Bar<T, T2>(string value, string value2);
        public void Bar2();
        public void WriteString(char* pSrcStart, char* pSrcEnd);
    }

    public class Foo<T>
    {
        public T Field;

        public Foo();

        public T this[T p] { get; }

        public T Property { get; }

        public T Method(T p);
    }

    [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]
    public sealed class FooAttribute : Attribute
    {
        public FooAttribute();
        [Foo(null, "\\n", true, false, 0, '\'', 0, 0, 0, 0, 0, 0, 0, 0, 0, typeof(object), Flags.None, Flags.A, Flags.A, Flags.AB | Flags.C, Flags.AB, (Flags)100)]
        public FooAttribute(object object1, string s1, bool bool1, bool bool2, byte byte1, char ch1, double double1, float float1, int int1, long long1, sbyte sbyte1, short short1, uint uint1, ulong ulong1, ushort ushort1, Type type, Flags f1, Flags f2, Flags f3, Flags f4, Flags f5, Flags f6);
    }

    public class FooCollection : ICollection, ICollection<Foo>, IEnumerable<Foo>
    {
        public FooCollection();

        public int Count { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public object SyncRoot { get; }

        public void Add(Foo item);
        public void Clear();
        public bool Contains(Foo item);
        public void CopyTo(Array array, int index);
        public void CopyTo(Foo[] array, int arrayIndex);
        public IEnumerator GetEnumerator();
        public bool Remove(Foo item);
    }

    [Obsolete]
    public class FooDic<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable<TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyList<KeyValuePair<TKey, TValue>> where TKey : Foo where TValue : Foo
    {
        public FooDic();
    }

    public class FooEvent : IFoo, IFoo2
    {
        public FooEvent();

        public void Bar();
    }

    public class FooException<T> : Exception
    {
        public FooException();
        protected FooException(SerializationInfo info, StreamingContext context);
        public FooException(string message);
        public FooException(string message, Exception inner);
    }

    public static class FooExtensions
    {
    }

    public class FooOfString : Foo<string>
    {
        public string Field;

        public FooOfString();

        public string this[string p] { get; }

        public string Property { get; }

        public string Method(string p);
        public string ToString();
    }

    public struct FooStruct
    {
        public void Bar();
    }

    public interface IFoo
    {
        event EventHandler Changed;

        void Bar();
    }

    public interface IFoo2
    {
        void Bar();
    }

    public interface IImmutableFoo<T> : IEquatable<IImmutableFoo<T>>, ICollection, IList, IStructuralComparable, IStructuralEquatable, ICollection<T>, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IImmutableList<T>
    {
        T this[int index] { get; set; }
    }

    [Flags]
    public enum Flags
    {
        None = 0,
        A = 1,
        B = 2,
        AB = A | B,
        C = 4,
        D = 8,
    }

    public delegate Foo FooDelegate(object p1, object p2);
}

[CLSCompliant(true)]
public class Bla
{
    public Bla();

    public void M();
}
