// --------------------------------------------------
// <auto-generated>
//     This file was generated by Roslynator.Documentation, Version=0.1.0.0, Culture=neutral, PublicKeyToken=14b2ed2c2cb945dc
//     Assemblies:
//         Roslynator.Documentation.TestProject, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5c61873a6e840f26
// </auto-generated>
// --------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Reflection;
using System.Runtime.Versioning;

// Roslynator.Documentation.TestProject
[assembly: AssemblyCompany("Josef Pihrt")]
[assembly: AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyInformationalVersion("1.0.0.0")]
[assembly: AssemblyProduct("Roslynator.Documentation.TestProject")]
[assembly: AssemblyTitle("Roslynator.Documentation.TestProject")]
[assembly: TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = "")]

namespace System
{
    [CLSCompliant(true)]
    [Obsolete]
    public class ClassName<Methods>
    {
        public ClassName();

        public void MethodName();
    }
}

namespace Roslynator.Documentation.Test
{
    public class B
    {
        public const string FooConst = "abc";

        public string Field;

        public B();

        public event EventHandler Event;

        public int this[[Foo] [Foo] int index1, [Foo] int index2, [Foo] int index3] { get; }

        public string Property { [Foo] [Foo] get; }

        public string Method([Foo] [Foo] string s1, [Foo] string s2, [Foo] string s3);
    }

    public class C : B
    {
        public string Field;

        public C();

        public event EventHandler Event;

        public int this[int index] { get; }

        public string Property { get; }

        public string Method();
        public string ToString();
    }

    [Obsolete("Foo is obsolete.")]
    public class Foo : Bla
    {
        public const string FooConst = "abc";

        public readonly string Field;

        public Foo(string s);
        public Foo(string s, string examples);

        public Foo this[int index, int index2] { get; set; }
        public Foo this[int index] { get; set; }

        public void Bar();
        public void Bar<T, T2>(string value, string value2);
        public void Bar2();
        public void WriteString(char* pSrcStart, char* pSrcEnd);
    }

    [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]
    public sealed class FooAttribute : Attribute
    {
        public FooAttribute();
        [Foo(null, "\\n", true, false, 0, '\'', 0, 0, 0, 0, 0, 0, 0, 0, 0, typeof(object), Flags.None, Flags.A, Flags.A, Flags.AB | Flags.C, Flags.AB, (Flags)100)]
        public FooAttribute(object object1, string s1, bool bool1, bool bool2, byte byte1, char ch1, double double1, float float1, int int1, long long1, sbyte sbyte1, short short1, uint uint1, ulong ulong1, ushort ushort1, Type type, Flags f1, Flags f2, Flags f3, Flags f4, Flags f5, Flags f6);
    }

    public class FooCollection : ICollection, ICollection<Foo>, IEnumerable<Foo>
    {
        public FooCollection();

        public int Count { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public object SyncRoot { get; }

        public void Add(Foo item);
        public void Clear();
        public bool Contains(Foo item);
        public void CopyTo(Array array, int index);
        public void CopyTo(Foo[] array, int arrayIndex);
        public IEnumerator GetEnumerator();
        public bool Remove(Foo item);
    }

    [Obsolete]
    public class FooDic<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable<TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyList<KeyValuePair<TKey, TValue>> where TKey : Foo where TValue : Foo
    {
        public FooDic();
    }

    public class FooEvent : IFoo, IFoo2
    {
        public FooEvent();

        public void Bar();
    }

    public static class FooExtensions
    {
    }

    public struct FooStruct
    {
        public void Bar();
    }

    public interface IFoo
    {
        event EventHandler Changed;

        void Bar();
    }

    public interface IFoo2
    {
        void Bar();
    }

    public interface IImmutableFoo<T> : IEquatable<IImmutableFoo<T>>, ICollection, IList, IStructuralComparable, IStructuralEquatable, ICollection<T>, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IImmutableList<T>
    {
        T this[int index] { get; set; }
    }

    [Flags]
    public enum Flags
    {
        None = 0,
        A = 1,
        B = 2,
        AB = A | B,
        C = 4,
        D = 8,
    }

    public delegate Foo FooDelegate(object p1, object p2);
}

[CLSCompliant(true)]
public class Bla
{
    public Bla();

    public void M();
}
